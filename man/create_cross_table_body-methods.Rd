% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_cross_table_body.R
\name{create_cross_table_body}
\alias{create_cross_table_body}
\alias{create_cross_table_body,data.frame-method}
\title{Create a styled cross table body}
\usage{
create_cross_table_body(data, ...)

\S4method{create_cross_table_body}{data.frame}(
  data,
  sub_table_cols = NULL,
  sub_heading_stylings = NULL,
  body_styling = NULL,
  y_cols_left = NULL,
  y_cols_right = NULL,
  x_cols = NULL,
  value_cols = NULL,
  value_col_stylings = NULL,
  drop_missing_rows = TRUE,
  drop_missing_cols = FALSE,
  aggregation = NULL,
  fill_values = NULL
)
}
\arguments{
\item{data}{A data.frame that should be used for the creation of the cross table.}

\item{...}{Various arguments}

\item{sub_table_cols}{(optional) A vector of column names that should be used in order to separate the data.frame into several sub tables, that will be concatenated vertically. Each sub table will have a sub heading row above the sub table body. The sub heading text is just the corresponding value in the column defined by \code{sub_table_cols}. If no sub heading should be introduced at all, the argument \code{sub_table_cols} should be omitted. If the \code{sub_table_cols} is a vector with more than one column name, then a hirachy level is introduced for the sub headings, where the first column has the highest and the column given by the last entry in \code{sub_table_cols} has the lowest hirachy level.}

\item{sub_heading_stylings}{(optional) A list of styling functions. A styling function is a function that takes a \link{StyledTable} object as its only argument and returns a styled function. The first styling function is applied to the level-1 sub heading (the sub heading defined by the first entry in \code{sub_table_cols}), the second styling function is applied to the level-2 sub heading etc. Alternatively a single styling function can be passed into \code{sub_heading_stylings}, in this case this styling function is applied to all sub heading levels.}

\item{body_styling}{(optional) A styling function that is applied to the generated styled body of each sub table. A styling function is a function that takes a \link{StyledTable} object as its only argument and returns a styled function. In order to format the value columns of the resulting cross table use the argument \code{value_col_stylings}.}

\item{y_cols_left}{(optional) A vector of column names that are unchanged by the cross table compuation and are printed to the left of the resulting cross table columns. This argument can be omitted, if no Y columns to the left of the cross_table are needed, but it is not allowed to omit both \code{y_cols_left} and \code{y_cols_right}.}

\item{y_cols_right}{(optional) A vector of column names that are unchanged by the cross table compuation and that are printed to the right of the cross table. This argument can be omitted, if no Y columns to the right of the cross_table are needed, but it is not allowed to omit both \code{y_cols_left} and \code{y_cols_right}.}

\item{x_cols}{(optional) A vector of column names that are used for column name generation by the cross table compuation. If the table should not be a cross table, but a normal table this argument can be omitted.}

\item{value_cols}{(optional) A vector of column names that are used as value columns by the cross table compuation. Normally this is just one column. If  it is a vector with several column names, then the column names of these columns introduce an extra level in the cross table column hirachy.}

\item{value_col_stylings}{(optional) A single column styling function or a list of column styling functions that has the same length as \code{value_cols}. Each column styling function is applied to the corresponding value column (defined to the corresponding column defined by the \code{value_cols} argument) of the resulting styled cross table. If a single column styling function is passed, then the same column styling function is applied to all value columns defined in \code{value_cols}. If no value column specific styling should be applied, then the \code{value_col_stylings} argument should be omitted. If the resulting table should not be a cross table at all, but a normal table, then  this argument should also be omitted. A column styling function is a function of the type: function(st, cols) {...}, which returns a \link{StyledTable} object, where \code{st} is a \link{StyledTable} object and \code{col_id} is a numeric vector of column numbers.}

\item{drop_missing_rows}{(optional) If set to \code{FALSE} and the \code{sub_table_cols} or \code{y_cols_left} are sparse factors then the missing factor levels introduce new rows filled filled with NAs. Otherwise no extra rows will be generated. Default value is \code{TRUE}.}

\item{drop_missing_cols}{(optional) If set to \code{FALSE} and the \code{x_cols} are sparse factors then the missing factor levels introduce extra cross table columns filled with \code{NA}. Otherwise no extra columns will be generated. Default value is \code{FALSE}.}

\item{aggregation}{(optional) Defines the function that will be used for the cross table cell aggregation. If not defined, the default aggregation function of the \code{\link[data.table:dcast.data.table]{data.table::dcast()}} function will be used.}

\item{fill_values}{(optional) A list of values that is used to fill the missing values in the \strong{value columns} in the calculated cross table. The first list value is used for the first \strong{value column}, the second value for the second \strong{value column}. Hence, the list given in \code{fill_values} should have the same length as the \code{value_cols} and the types of the \code{fill_values} should be the same as the corresponding \strong{value columns} in the \code{data} data.frame. If the argument is omitted, then only \code{NA} is filled in for the missing cross table values. Caution: If an Excel file is generated from this cross table, \code{NA} values will be replaced by empty strings.}
}
\value{
The generated \link{StyledTable} object holding the styled table body rows
}
\description{
This function creates the styled cross table body from a given data.frame.
This function works best in combination with the method \code{\link[=create_cross_table_header]{create_cross_table_header()}} and \code{\link[=styled_table]{styled_table()}}.
For the the creation of the styled cross table body the columns specified in \code{sub_table_cols} are used to separate the
table body into several sub tables, where each sub table has the current
value in the column defined by \code{sub_table_cols} as sub heading.
The columns specified in \code{y_cols_left}, \code{x_cols} and \code{value_cols}
will be used for the cross table calculation.
If the table should not be a cross table, but a normal table then the
arguments \code{x_cols} and \code{value_cols} should be omitted.
}
\examples{
\dontrun{
library(dplyr)
# prepare data set for cross table
students_data <- data.frame(
    country = rep(c("Germany", "Austria"), each = 16),
    year = c(rep("2010", 8), rep("2011", 8)),
    subject = rep(c(rep("Mathematics", 4), rep("Statistics", 4)), 2),
    gender = rep(c(rep("Male", 2), rep("Female", 2)), 4),
    result = rep(c("positive", "negative"), 16),
    N = sample(1:1000, 32)
  ) \%>\%
  group_by(country, year, subject, gender) \%>\%
  mutate(rel = 100 * N / sum(N)) \%>\%
  ungroup
# setup styled header
s_header <- create_cross_table_header(
    y_col_headings = c("Year", "Subject"),
    cross_table_heading = "Comparison of test results",
    c("Male", "Female"),
    c("Positive", "Negative"),
    c("count", "in \%")
  ) \%>\%
  format_stat_header
# setup styled cross table body
s_body <- create_cross_table_body(
    data = students_data,
    sub_table_cols = "country",
    sub_heading_styling = function(st) set_horizontal(st, "center"),
    body_styling = function(st) set_horizontal(st, "center"),
    y_cols_left = c("year", "subject"),
    x_cols = c("gender", "result"),
    value_cols = c("N", "rel"),
    value_col_stylings = list(
      format_stat_absolute,
      format_stat_relative
    ),
    fill_values = list(0L, 0)
  )
# Concat styled header and styled body into a single styled table
s_tbl <- styled_table(
    s_header,
    s_body
  )
s_tbl \%>\%
  write_png
}
}
